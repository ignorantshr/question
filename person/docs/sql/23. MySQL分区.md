[TOC]

通过查看插件检查是当前MySQL版本否支持分区：

```mysql
SHOW PLUGINS;
```

若存在`partition`记录并且是`ACTIVE`状态则表示支持。

当创建分区表并使用InnoDB引擎时`DATA DIRECTORY`、`INDEX DIRECTORY`选项无效。

## 概念

​		分区将一张表分为几个分区进行存储，本质上还是一张表。分区键用于根据某个区间值、特定值列表或hash函数值执行数据的聚集，让数据更具分布规则分布在不同的分区中，让一个大对象变成一些小对象。



分区的优点：

- 可以在一个表中存储比在单个磁盘或文件系统分区上能保存的更多的数据。
- 可以轻松的移除或添加分区达到删除数据或新增存储数据的空间。
- 一些查询可以得到很好的优化。
- 跨多个磁盘分散数据查询，获得更大的吞吐量



## 分区表的创建

```mysql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]

partition_options:
    PARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY(column_list)
        | RANGE{(expr) | COLUMNS(column_list)}
        | LIST{(expr) | COLUMNS(column_list)} }
    [PARTITIONS num]
    [SUBPARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY(column_list) }
      [SUBPARTITIONS num]
    ]
    [(partition_definition [, partition_definition] ...)]
    
partition_definition:
    PARTITION partition_name
        [VALUES
            {LESS THAN {(expr | value_list) | MAXVALUE}
            |
            IN (value_list)}]
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'comment_text' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [NODEGROUP [=] node_group_id]
        [(subpartition_definition [, subpartition_definition] ...)]
    
-- 详细的说明执行 `? CREATE TABLE;` 查看
```

分区选项一定要放在最后。

指定表的分区数`PARTITIONS num`时，必须将其表示为不带前导零的非零正整数，并且不是0.8E + 01或6-2等表达式，即使它的计算结果为整数值。不允许使用小数部分。

要么分区表上没有主键/唯一键，要么使用主键/唯一键都必须包含分区键。

分区的名字不区分大小写。

## 查看分区

查看分区状态：

```mysql
SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'table_name';
```

查看分区执行过程：

```mysql
EXPLAIN PARTITIONS sql_statement;
```

## 删除分区

和删除表一样，使用 `TRUNCATE` 清空分区（比`DELETE`要快），使用`DROP`删除分区：

```mysql
ALTER TABLE table_name TRUNCATE PARTITION partition_name;
ALTER TABLE table_name DROP PARTITION partition_name;
```

## 分区类型

通过`KYE`或`LINEAR KEY`分区时，可以使用`DATE,TIME,DATETIME`类型的字段作为分区字段。

通过`RANGE COLUMNS`和`LIST COLUMNS`分区时，可以使用`DATE,DATETIME`类型的字段作为分区字段。

其它的分区类型在要求一个返回整型数值或NULL的分区表达式。

### RANGE 分区

按范围分区的表的分区方式是：每个分区包含分区表达式值位于给定范围内的行。

范围应该是**连续但不重叠的**，并且使用`VALUES LESS THAN`运算符定义。

- NULL会被当作最小值来处理
- 支持使用`DATE,DATETIME`类型的字段作为分区键
- 支持使用`UNIX_TIMESTAMP,YEAR`等函数进行分区

```mysql
CREATE TABLE `range_test` (
  `ID` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
/*!50100 PARTITION BY RANGE (ID)
(PARTITION P0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION P1 VALUES LESS THAN (10) ENGINE = InnoDB,
 -- MAXVALUE表示最大的可能的整数值
 PARTITION P3 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */

-- /*!...*/ 是MySQL的扩展特性。是一种特殊的注释，其他的数据库产品当然不会执行。mysql特殊处理，会选择性的执行。特别注意 50100，它表示5.01.00 版本或者更高的版本，才执行。

-- 使用DATE类型的字段作为分区键
CREATE TABLE members (
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE COLUMNS(joined) (
    PARTITION p0 VALUES LESS THAN ('1960-01-01'),
    PARTITION p1 VALUES LESS THAN MAXVALUE
);

-- 使用UNIX_TIMESTAMP函数进行分区
CREATE TABLE quarterly_report_status (
    report_id INT NOT NULL,
    report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
PARTITION BY RANGE ( UNIX_TIMESTAMP(report_updated) ) (
    PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
    PARTITION p1 VALUES LESS THAN (MAXVALUE)
);

-- 使用YEAR等函数进行分区
CREATE TABLE employees (
    id INT NOT NULL,
    separated DATE NOT NULL DEFAULT '9999-12-31',
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN MAXVALUE
);
```

`RANGE`分区类型特别适合以下几种情况：

- 需要删除旧数据时。可以很轻松地通过删除分区来删除旧数据。`ALTER TABLE employees DROP PARTITION p0;`
- 使用包含日期或时间值的列，或包含来自其他一些系列的值。
- 经常运行包含分区键的查询。

### LIST 分区

`LIST`分区时建立离散的值列表告诉数据库特定的值属于哪个分区。

与RANGE分区的区别：是LIST分区从属于一个枚举列表的值的集合，RANGE分区是从属于一个连续区间值的集合。

与RANGE分区不同，没有类似于*MAXVALUE*的值来匹配所有的情况；**所有被期望的值**都应该被包含进`PARTITION ... VALUES IN (...)`子句。

使用单个INSERT语句插入多行时，行为取决于表是否使用事务存储引擎：

- 对于支持事务的存储引擎，整个插入语句会被当做一个单一的事务。
- 对于不支持事务的存储引擎，在包含未匹配值的之前的记录会被插入，自己及其之后的不会。

可以使用`IGNORE`关键字忽略此类错误，如此一来，包含未匹配的值的记录不会插入，其余的都会被插入到数据库并且不会发出错误。

```mysql
MariaDB [MYISAM_TEST]> CREATE TABLE IF NOT EXISTS list_test (ID INT) MAX_ROWS=8 
PARTITION BY LIST (ID) (
    PARTITION P0 VALUES IN (1,2,3,4,5),
    PARTITION P1 VALUES IN (6,7,8)
);

MariaDB [MYISAM_TEST]> INSERT INTO list_test VALUES (1),(3),(9);
ERROR 1526 (HY000): Table has no partition for value 9

MariaDB [MYISAM_TEST]> INSERT IGNORE INTO list_test VALUES (1),(3),(9);
Query OK, 2 rows affected, 1 warning (0.00 sec)
Records: 3  Duplicates: 1  Warnings: 1

MariaDB [MYISAM_TEST]> SELECT * FROM list_test;
+------+
| ID   |
+------+
|    1 |
|    3 |
+------+
```

### COLUMNS 分区

列分区是`RANGE`和`LIST`分区的变种。COLUMNS分区允许在分区键中使用多个列。

`RANGE COLUMNS` 分区和`LIST COLUMNS` 分区都支持非整型（non-integer）字段作为值的范围或列的成员，以下是运行的数据类型：

- 所有的整数类型：TINYINT, SMALLINT, MEDIUMINT, INT (INTEGER), BIGINT
- 部分时间类型：DATE 和 DATETIME
- 部分字符串类型：CHAR, VARCHAR, BINARY,  VARBINARY

#### RANGE COLUMNS 分区

这种分区类型可以使用整数类型以外的类型列来定义范围。

RANGE COLUMNS 与 RANGE 分区的不同：

- RANGE COLUMNS 不接受表达式，只接受字段名。
- RANGE COLUMNS 接受一个或多个字段组合的列表。
    - RANGE COLUMNS 划分基于元组之间的比较
- RANGE COLUMNS 不受限于整数类型。其它类型也可以用作分区字段。

```mysql
CREATE TABLE table_name
PARTITIONED BY RANGE COLUMNS(column_list) (
    PARTITION partition_name VALUES LESS THAN (value_list)[,
    PARTITION partition_name VALUES LESS THAN (value_list)][,
    ...]
)

column_list:
    column_name[, column_name][, ...]

value_list:
    value[, value][, ...]
```

创建举例：

```mysql
mysql> CREATE TABLE rcx (
    ->     a INT,
    ->     b INT,
    ->     c CHAR(3),
    ->     d INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,d,c) (
    ->     PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    ->     PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
    ->     PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    ->     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
Query OK, 0 rows affected (0.15 sec)
```

分区的定义必须遵从递增的顺序，否则会报错：

```mysql
-- 正确
CREATE TABLE rc4 (
    a INT,
    b INT,
    c INT
)
PARTITION BY RANGE COLUMNS(a,b,c) (
    PARTITION p0 VALUES LESS THAN (0,25,50),
    PARTITION p1 VALUES LESS THAN (10,20,100),
    PARTITION p2 VALUES LESS THAN (10,30,50)
    PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
 );

-- 错误
mysql> CREATE TABLE rcf (
    ->     a INT,
    ->     b INT,
    ->     c INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,b,c) (
    ->     PARTITION p0 VALUES LESS THAN (0,25,50),
    ->     PARTITION p1 VALUES LESS THAN (20,20,100),
    ->     PARTITION p2 VALUES LESS THAN (10,30,50),
    ->     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    ->  );
ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
```



##### RANGE COLUMNS 划分基于元组之间的比较的解释

举例说明：

```mysql
-- 创建分区表
MariaDB [MYISAM_TEST]> CREATE TABLE rc1 (
    ->     a INT,
    ->     b INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a, b) (
    ->     PARTITION p0 VALUES LESS THAN (5, 12),
    ->     PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
    -> );
    
-- 插入数据
MariaDB [MYISAM_TEST]> INSERT INTO rc1 VALUES (5, 2), (5, 10), (5, 12);

-- 查看数据分布
MariaDB [MYISAM_TEST]> SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'rc1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          2 |
| p3             |          1 |
+----------------+------------+
```

多行分区对于分区键的比较是对元组进行比较，类似于这样：

```mysql
mysql> SELECT (5,10) < (5,12), (5,11) < (5,12), (5,12) < (5,12);
+-----------------+-----------------+-----------------+
| (5,10) < (5,12) | (5,11) < (5,12) | (5,12) < (5,12) |
+-----------------+-----------------+-----------------+
|               1 |               1 |               0 |
+-----------------+-----------------+-----------------+
1 row in set (0.00 sec)
```

#### LIST COLUMNS 分区

这种分区类型可以使用多个字段作为分区键，并使用整数类型以外的类型列来定义范围。

与RANGE COLUMNS 类似，参考上文说明。



多个字段作为分区键的写法：

```mysql
CREATE TABLE lc (
    a INT NULL,
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
```

### HASH 分区

通过`HASH`进行分区主要用于确保在预定分区数量之间均匀地分布数据。


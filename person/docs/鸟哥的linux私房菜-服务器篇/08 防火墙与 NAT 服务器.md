Linux 的防火墙主要是透过 `Netfilter` 与 `TCP Wrappers` 两个机制来管理的。

[Linux就该这么学-防火墙章节](https://www.linuxprobe.com/chapter-08.html)

## 认识防火墙

只要能够分析与过滤进出我们管理的网络的数据包，就可以称为防火墙。

防火墙又可以分为硬件防火墙与本机的软件防火墙。硬件防火墙包过滤的效率较佳。

鸟哥建议利用 *shell script* 来撰写属于自己的防火墙机制比较好，因为对于规则的排序与汇总有比较好的观察性，可以让防火墙规则比较清晰一点。

### 防火墙的作用

防火墙最重要的任务就是规划出：

- 切割被信任（如子域）与不被信任（如 Internet）的网段；
- 划分出可提供 Internet 的服务与必须受保护的服务；
- 分析出可接受与不可接受的包状态。

Linux 的 `iptables` 防火墙软件还可以进行更细部深入的 NAT （Network Address Translation）的设定，进行更弹性的 IP 数据包伪装功能。

### Linux 系统上防火墙的分类

依据防火墙管理的范围，我们可以将防火墙区分为网域型与单一主机型的管控。

单一主机型的控管方面，主要的防火墙有包过滤型的 `Netfilter` 与依据服务软件程序作为分析的 `TCP Wrappers` 两种。

若以区域型的防火墙而言，由于此类防火墙都是当作路由器角色，因此防火墙类型主要则有 `Netfilter` 与利用`代理服务器` (proxy server) 进行存取代理的方式了。

#### Netfilter

分析进入主机的网络包，将包的表头数据拿出来进行分析，以决定对该联机实行放行或抵挡。

包括 *硬件地址(MAC), 软件地址 (IP), TCP, UDP, ICMP* 等包的信息都可以进行过滤分析的功能。主要分析的是 OSI 七层协议的 2, 3, 4 层。

在 Linux 上面使用`iptables`或`firewall`来实现。非常适合于一般小型环境。

#### TCP Wrappers

通过服务器程序的外挂 （`tcpd`）来处置的。分析谁对某**程序**进行存取，然后透过规则去分析该服务器程序谁能够联机、谁不能联机。

#### 代理服务器

其实代理服务器是一种网络服务，它可以**代理**用户的需求，而代为前往服务器取得相关的资源。

### 防火墙的一般网络布线示意

#### 单一网域，仅有一个路由器

![](img/单一网域_单一路由器的环境.png)

将 Linux 架设在路由器上面以管控整个局域网络的包进出。

- 因为内外网域已经分开，所以安全维护在内部可以开放的权限较大
- 安全机制的设定可以针对 Linux 防火墙主机来维护即可
- 对外只看的到 Linux 防火墙主机，所以对于内部可以达到有效的安全防护

#### 内部网络包含安全性更高的子网，需内部防火墙切开子网

![](img/内部包含安全性更高子网的环境.png)

如果有特别重要的部门需要更安全的保护网络环境,那么将 LAN 里面再加设一个防火墙，将安全等级分类，可以防止一些内部破坏和盗取。

#### 在防火墙的后面架设网络服务器主机

![](img/将服务器放在防火墙后的环境.png)

将提供网络服务的服务器放在防火墙后面。通常像上图的环境中，将网络服务器独立放置在两个防火墙中间的网络，我们称之为非军事区域 (`DMZ`)，即缓冲地带的意思。

Web, Mail 与 FTP 都是透过防火墙连到 Internet 上面去，所以，这四部主机在 Internet 上面的 Public IP 都是一样的。

内部网络如果发生状况时，是不会影响到网络服务器的正常运作的。

在配置一个拥有DMZ区的网络的时候通常定义以下的[访问控制策略](https://baike.baidu.com/item/DMZ/631225?fr=aladdin#4)以实现DMZ区的屏障功能：

1. **内网可以访问外网**
2. **内网可以访问DMZ**
3. **外网不能访问内网**
4. **外网可以访问DMZ**
5. **DMZ访问内网有限制**
6. **DMZ不能访问外网**：邮件服务器等必须访问的除外。

DMZ的目的是把敏感的内部网络和其他提供访问服务的网络分开，阻止内网和外网直接通信，以保证内网安全。

### 防火墙的使用限制

- 防火墙并不能很有效的抵挡病毒或木马程序
- 防火墙对于来自内部 LAN 的攻击较无承受力

此时就需要前文的网络安全知识来预防了。

## TCP Wrappers

TCP wrappers 就是透过 `/etc/hosts.allow, /etc/hosts.deny`这两个文件来管理的一个类似防火墙的机制。

支持该规则的只有以下软件：

- 由 `super daemon (xinetd)` 所管理的服务，即

    配置文件在`/etc/xinetd.d/`下面的服务；//TODO 在centos6.x中查看

- 支持 `libwrap.so` 模块的服务。

可以使用`ldd`指令来查看一个服务是否包含`libwrap.so`库文件：

```
root@sink:~# ldd $(which sshd) | grep libwrap.so
	libwrap.so.0 => /lib/x86_64-linux-gnu/libwrap.so.0 (0x00007f2618235000)
```

### 配置文件的语法

`/etc/hosts.allow, /etc/hosts.deny`两个文件的语法（更复杂的语法参考`man hosts_access`）是一样的：

```
<service(program_name)> : <IP, domain, hostname>
```

这两个文件与规则的优先级是这样的：

1. 先以 /etc/hosts.allow 比对，该规则符合就予以放行；
2. 再以 /etc/hosts.deny 比对，规则符合就予以抵挡；
3. 若不在这两个文件内，亦即规则都不符合，最终则予以放行。

#### 举例说明

先开放本机的 127.0.0.1 可以进行任何本机的服务，然后,让区网 (192.168.1.0/24) 可以使用 rsync ，同时 10.0.0.100 也能够使用 rsync ，但其他来源则不允许使用 rsync。那么规则设置如下：

```
root@sink:~# cat /etc/hosts.allow
ALL: 127.0.0.1
rsync: 192.168.1.0/255.255.255.0, 10.0.0.100

root@sink:~# cat /etc/hosts.deny
rsync: ALL
```


tcp wrappers 理论上不支持 192.168.1.0/24 这种透过 bit 数值来定义的网段，只支持 netmask 的地址显示方式。

## iptables

![](img/网络包过滤规则流程.png)

上图的主要目的是告诉你：**规则是有顺序的**！当符合了一个规则时，就不会继续进行规则的对比了。

### iptables 的表格（table）与链（chain）

`iptables`中有多个表格，每个表格中又有多个链，每个链下又有规则。

那么 iptables 中主要有三张表：

- filter：管理本机进出的数据包，为默认的table
    - INPUT：过滤进入的数据包；
    - OUTPUT：过滤输出；
    - FORWARD：过滤转发包，即与 `ip forward`有关，和下面的`nat table`相关性较高。
- nat：主要在进行来源与目的的 IP 或 port 的转换
    - PREROUTING：在进行路由判断之前所要对比的规则；
    - POSTROUTING：路由判断之后；
    - OUTPUT。
- mangle：主要是与特殊的封包的路由旗标（flag）有关。

各个表之间的关系图：

![](img/iptables中表的关系.png)

由上图可以看出，iptables 可以控制三种包的流向：

- 包进入 Linux 主机使用资源（A）：路由判断之后确定是从主机获取资源；
- 包经由 Linux 主机的转发，向后端主机流动（B）；
- 包由 Linux 本机发送出去（C）。

!!! note
	因为网络是**双向的**，所以进入与输出要分开来看，故有两次路由判断！

### iptables 语法

#### 规则的查看

```
iptables [-t tables] [-L] [-nv]

	-t :后面接 table ，例如 nat 或 filter ，若省略此项目,则使用默认的 filter
	-L :列出目前的 table 的规则
	-n :不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！
	-v :列出更多的信息
```

```
root@sink:~# iptables -L -n
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy DROP)
target     prot opt source               destination                    
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
……
```

表头的含义：

- policy：预设的政策（动作）
- target：本条规则的动作
- prot：是什么协议
- opt：额外的选项说明
- source：此规则针对的*源IP*
- destination：*目的IP*

```
iptables-save [-t table] [-f filename]

	-f, --file filename      Specify a filename to log the output to. 默认输出到STDOUT.
```

虽然`iptables-save`是一个存储指令，但是可以详细查看防火墙规则：

```
root@sink:~# iptables-save
# Generated by xtables-save v1.8.2 on Sun Mar 22 21:24:03 2020
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
……
COMMIT
*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
……
```

#### 规则的清除

```
iptables [-t tables] [-DFXZ]

	-D chain ：从 chain 中清除符合条件的规则；
	-D chain rulenum ：rulenum (1 = first)；
	
	-F ：清除所有的规则；
	-X ：清除所有使用者 "自定义" 的 chain (应该说的是 tables )啰；
	-Z ：将所有的 chain 的计数与流量统计都归零
```

#### 定义预设政策 (policy)

假设你对于内部的使用者有信心的话，那么 filter 内的 INPUT 链方面可以定义的比较严格一点，而 FORWARD 与 OUTPUT 则可以宽松一点。

```
iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]

	-P ：定义政策( Policy )。
	ACCEPT ：该包可接受
	DROP   ：该包直接丢弃，不会让 client 端知道为何被丢弃。
```

```
root@sink:~# iptables -P INPUT DROP
root@sink:~# iptables -L
Chain INPUT (policy DROP)
……
```

#### 规则的制定

```
iptables [-AI 链] [-io 网络接口] [-p tcp,udp] [-s 来源 IP/网域] [--sport 端口范围] [-d 目标 IP/网域] [--dport 端口范围] -j [ACCEPT|DROP|REJECT|LOG]

	-A	在最后面新增一条规则
	-I num	若没有指定顺序，则插入变成第一条规则
	-i	包进入的网口，例如 eth0；需要与 INPUT 配合
	-o	
	-p	指定规则针对的协议类型。可以使用"all"
	-s	来源 IP/网域，格式为“address[/mask][...]”
	-d	
	-j	动作。LOG：仅仅记录到 /var/log/messages 中，不进行对比。
	
其中 iosdp 选项的参数前面都是可以加前缀"!"的，表示相反的意思。若设置的时候没有指定某个参数，表示该参数完全接受！
```

```bash
# 将 lo 设置为信任网口
root@sink:~# iptables -A INPUT -i lo -j ACCEPT
root@sink:~# iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             anywhere
```


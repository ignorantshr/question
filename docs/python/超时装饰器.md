超时装饰器
```python
def setTimeout(second=5):
    def wrap(function):
        def handle(signal, frame):
            raise RuntimeError

        def timing(second):
            while second != 0:
                second -= 1
                time.sleep(1)

        def to_do(*args, **kwargs):
            try:
                signal.signal(signal.SIGALRM, handle)
                signal.alarm(second)
                re = function(*args, **kwargs)
                signal.alarm(0)
                return re
            except RuntimeError as e:
                raise e
        return to_do
    return wrap
```

如果function是当前线程阻塞式的，那么这段代码不会发生作用。

与shell命令结合使用：[执行shell命令](执行shell命令.md)

*附*：无法使用signal判断的情况

但是，在vdsm中调用时，却提示`signal`不能在子线程中使用，所以不能使用这种方法，改写成下面这种方法：
```python
def _isSSHEnable(remoteIP):
    cmd = ["ssh root@" + remoteIP, 'df /']
    flag = 'unknown'

    def timer(pro):
        n = 5
        while n != 0:
            n -= 1
            time.sleep(1)

        if flag is not 'ok':
            pro.terminate()

    sub = subprocess.Popen(' '.join(cmd), shell=True, stdout=subprocess.PIPE)
    timeout = threading.Thread(target=timer, args=(sub,))
    timeout.start()
    timeout.join()
    code = sub.wait()
    flag = 'ok'
    if code != 0:
        return False
    return True
```
这种方法的问题就是不管该程序是不是超时运行，都要等待5秒的时间。

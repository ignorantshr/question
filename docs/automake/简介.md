[TOC]

2018-11-19
# Automake介绍
Automake是从Makefile.am(定义一系列make变量的文件)自动生成Makefile.in文件的工具。生成的Makefile.in符合GNU Makefile 标准。

因为不同的平台需要修改Makefile，所以编写`configure`脚本自动修改Makefile，再执行`./configure && make && make install`命令安装包，形成了GNU构建系统。
# Autotools介绍
`Autotools`是为包创建GNU构建系统的工具；`Autoconf`主要关注`configure`；`Automake`主要关注`Makefile`。

当安装一个程序时，安装步骤有以下几步：

- tar -zxf xxx.tar.gz
- cd xxx
- ./configure #检查要求的环境，生成包括Makefile（s）在内的多个文件
- make #构建所有的文件结构，生成文件
- make check #源码检查
- su 切换到root用户
- make install #复制源码文件到目的目录
- make installcheck #安装后检查

*note*：

- make uninstall 需要在构建树下运行
- make clean 删除make生成的文件
- make distclean 额外删除 ./configure生成的文件
- make dist 从源码重新创建xxx.tar.gz

有一些可配置变量，可以通过`./configure --help`查看完整版
如果想配置系统默认变量，可以修改`/usr/local/share/config.site`文件中指定

#### 对比源码树与构建树
**源码树**：包含了configure文件的所有源文件

**构建树**：在源码树的基础上，包含上运行configure之后派生出来的文件。通常目录结构与源码树一致，子目录是被构建系统自动创建出来的
##### 虚拟路径构建
可以在解压完压缩包之后在任意位置新建一个build子文件夹并在该文件夹下执行后续步骤，所有的派生文件会存放在build目录下，这样的构建叫做`parallel build`或者`VPATH builds`。

虚拟路径构建可以创建多个子文件夹进行构建，这样就可以使用不同的参数构建同一份源码

## 一些特性
### 交叉编译
在指定的构建平台上编译可以在运行平台上执行的二进制文件
./configure --build指定构建平台，--host指定运行平台
*notes*：如果需要构建的包本身就是一个交叉编译器，需要使用--target参数指定架构

### 重命名程序
可以在执行configure的时候对安装的程序重命名，比如安装`tar`变为`gtar`<br>
以下三个参数可以满足该需求：

- --program-prefix	#给程序名字添加前缀
- --program-suffix	#给程序名字添加后缀
- --program-transform-name	#重命名程序

eg.
```shell
./configure --program-prefix tea
```

### 指定目的文件夹构建二进制文件
```shell
make DESTDIR=$HOME/inst install
```
此举会将程序安装在`~/inst`文件夹下，文件夹下包含了程序的安装结构
安装的目录结构如下所示：

![指定文件夹安装程序](img/安装到指定文件夹.png)

打包：
```shell
cd ~/inst
find . -type f -print > ../files.lst
tar zcvf ~/amhello-1.0-i686.tar.gz `cat ../files.lst`
```
如此一来，直接解压这个压缩包，就可以直接完成amhello的安装。

### 准备发布
使用`make distcheck`来保证包拥有所需要的构建步骤并且不会报错

- 尝试完整的打包、解包、运行make、make check、make install、make installcheck、make dist
- 测试只读源码树的`VPATH Builds`
- 保证make clean、make distclean、make uninstall不会遗漏任何文件
- 检查`DESTDIR`安装工作

## 生成构建系统
`autoreconfig`是一个按照正确执行autoconf、automake和一堆其它命令的脚本，用于生成构建系统。<br>
编写configure.ac、Makefile.am、main.c、README文件，执行
`autoreconfig --install`实例化一个构建系统

	autoconf负责从configure.ac生成configure文件
	automake负责从Makefile.am和configure.ac生成Makefile.in文件

*note*：只有构建系统没有时才执行`autoreconfig`，如果修改了`configure.ac`或者`Makefile.am`，执行make时会自动重新生成相关文件。`configure.ac`的语法参考Autoconf手册。

## 文件分析
### configure.ac

	AC_INIT([amhello], [1.0], [bug-automake@gnu.org])
	AM_INIT_AUTOMAKE([-Wall -Werror foreign])
	AC_PROG_CC
	AC_CONFIG_HEADERS([config.h])
	AC_CONFIG_FILES([
	 Makefile
	 src/Makefile
	])
	AC_OUTPUT

- `AC_`开头的是autocofig的宏；`AM_`开头的是automake的宏。
- AC_INIT 定义了包名、版本、联系地址
- AM_INIT_AUTOMAKE 括号中的是automake的选项。-Wall -Werror 意味着关闭警告并作为错误进行报告；foreign 不要遵守GNU的规则，GNU包总是还应该有其他的文件
- AC_PROG_CC 使configure脚本搜索C编译器然后用其名字定义变量CC，src/Makefile.in文件需要使用CC变量来构建hello
- AC_CONFIG_HEADERS 使configure脚本创建config.h文件收集在configure.ac文件中定义的宏
- AC_CONFIG_FILES 声明了configure文件应该从\*.in模板创建的文件列表，否则不会使用Makefile.am文件
- AC_OUTPUT 是一个关闭命令，是真正的负责生成文件（在AC_CONFIG_HEADERS和AC_CONFIG_FILES中注册的）的脚本部分

### src/Makefile.am

	bin_PROGRAMS = hello
	hello_SOURCES = main.c

与Makefile的语法一样。automake驱动该文件时会将整个内容复制到`Makefile.in`文件，但是会通过构建规则和其他变量对特定的变量定义做出反应。通常该文件只包含上述的变量定义列表，但也可以包含其他的变量和规则，只是automake仅仅传递他们，不对其进行处理。

- bin表明了安装位置
- 以`_PROGRAMS`结尾的特殊变量指定了Makefile应该构建的文件类型。Automake将这些变量称之为`primary`，其他的primary例如 _SCRIPTS， _DATA， _LIBRARIES 等等，对应不同的文件类型。
- bin 意味着程序应该被安装到`${exec_prefix}/bin`文件夹下
- hello_SOURCES 该声明的副作用是当执行`make dist`时main.c会成为tar包的一部分
- 因为程序需要从源文件构建，所以每个程序在一个`_PROGRAMS`变量中列出了`prog`，automake会寻找另一个名为`prog_SOURCES`的变量列出其所有的源文件。所有的源文件会被一起编译和链接。
### Makefil.am

	SUBDIRS = src
	dist_doc_DATA = README

- SUBDIRS 列出所有的在驱动当前目录之前make需要递归进入的文件夹，make install也会先安装src/hello，再安装README
- dist_doc_DATA `_DATA primary`列出的文件列表不会自动地成为tar包的一部分，所以加上了dist前缀来达到这个目的。唯一重要的影响是此行在`make install`的时候会安装README。

*note*：文件中没有涉及到安装路径，请参考autocong手册中的[Defining Directories](http://www.gnu.org/software/autoconf/manual/autoconf.html#Defining-Directories)。

# 基本理念
## 一般操作
Automake读取Makefile.am生成Makefile.in文件。某些在Makefile.am中定义的变量和规则指导Automake生成更加专用的代码。

大部分GNU make扩展不能被Automake所识别。

定义在Makefile.am或者configure.ac中的变量会覆盖automake的默认变量。

automake在检查变量定义的时候会递归检查所有引用的变量

注释以`##`开头

## 严格程度
虽然Automake旨在供GNU包维护中使用，但是并不想遵守其全部的规定。

有以下三个等级：

- foreign - 只检查正确操作所必须的东西。
- gnu - 会尽可能多的满足GNU标准。默认选项
- gnits - 会检查还未成文的GNU标准，比GNU标准更细。通常不会使用该选项

## 命名格式
Automake变量遵守`uniform naming scheme`，使何时程序被构建和如何被安装变得很容易。

一套不同的名字用来决定构建对象应该被安装到哪里。这些名字是primary的前缀，定义了哪个标准文件夹是安装目录。标准的文件夹名字参考 [Directory Variables](http://www.gnu.org/prep/standards/standards.html#Directory-Variables) in The GNU Coding Standards

可以自定义目录，任何在Makefile.am中以`dir`结尾的自定义变量都可以用作*primary*的合法前缀：
```make
	xmldir = $(datadir)/xml
	xml_DATA = file.xml
```

不是在每个文件夹的每个对象的每个部分都会被安装。Automake会标记这些错误。还会检查目录名的拼写错误。

对于每个primary，都有一个带有`EXTRA_`前缀的primary，这个变量用于列出可能构建的变量列表，在configure中决定是否构建。

`noinst_`前缀表示变量只构建不安装。

`check_`表明变量不能被构建直到`make check`命令运行。也不可安装。

所有的变量名期望 字母、数字、@、其它符号变为下划线，比如libmum++.a，派生变量会是libmum___a_SOURCES

超级前缀：

- dist #指明哪些文件应该被发布
- nodist
- nobase #去掉路径前缀，举例：
```
nobase_dist_include_HEADERS = \

  jupiter/jupiter_interface.h
```
正常情况下，该头文件会被安装到`/usr(/local)/include/jupiter_interface.h`，加了`nobase`前缀之后，会变为`/usr(/local)/include/jupiter/jupiter_interface.h`。

`nobase_`可以使用下面的写法代替:
```
nobase_dist_pkgdata_HEADERS = jupiter/jupiter.ogg

jupiterdir = $(pkgdatadir)/jupiter
dist_jupiter_DATA = jupiter/jupiter.ogg
```
EXTRA_DIST变量应该被加到发布包的文件或文件夹。

## 命令长度限制

例如
```make
	data_DATA = file1 … fileN fileN+1 … file2N
```
可以写成
```make
	data_DATA = file1 … fileN
	data2dir = $(datadir)
	data2_DATA = fileN+1 … file2N
```

## 用户保留变量
一些保留变量为构建包的用户使用，让他们的工作更轻松。但是这些变量不能出现在要求正确编译的包中。

Automake引入了特殊的阴影便量为用户标记变量。添加前缀`AM_`到用户变量名就是阴影变量。

# 一些示例包
- 已经使用Autoconf构建了一个项目with手写的Makefile文件，现在转换为使用Automake。参考[Autoconf -> Automake](http://www.gnu.org/software/automake/manual/automake.html#Complete) 没看懂。。。

- 使用不同的编译参数从一个文件构建两个项目。通过设定不同的变量名及其标志指向同一个文件俩达到效果
```make
	bin_PROGRAMS = true false
	false_SOURCES =
	false_LDADD = false.o

	true.o: true.c
	        $(COMPILE) -DEXIT_CODE=0 -c true.c

	false.o: true.c
	        $(COMPILE) -DEXIT_CODE=1 -o false.o -c true.c
```
true_SOURCES没有写，Automake会默认有一个true.c文件和默认的规则来编译true.o、链接true。[see Default \_SOURCES](http://www.gnu.org/software/automake/manual/automake.html#Default-_005fSOURCES)

```make
	bin_PROGRAMS = false true

	false_SOURCES = true.c
	false_CPPFLAGS = -DEXIT_CODE=1

	true_SOURCES = true.c
	true_CPPFLAGS = -DEXIT_CODE=0
```

该种写法会生成 false-true.o and true-true.o

# 创建一个Makefile.in文件
automake总是在项目的最顶层目录运行，这是必须的因为automake必须扫描configure.cac，还有一个原因就是一些Makefile.in文件在子目录中。

Automake会运行autoconf来扫描configure.ac和依赖，所有autoconf必须在PATH环境变量中。但是并不会构建configure脚本，所以仍然要你自己运行autoconf。

automake接受的一些选项。

# 使用`aclocal`扫描`configure.ac`
一些autoconf宏和变量要求必须定义在configure.ac中。Automake也支持一些Autoconf的宏使维护更加简单。这些宏可以使用aclocal程序自动地被放在`aclocal.m4`文件中。
[see Macros](http://www.gnu.org/software/automake/manual/automake.html#Macros)

## 配置要求
唯一的要求就是在configure.ac文件中加上`AM_INIT_AUTOMAKE`宏。

下面是几个Automake要求的但是不会被`AM_INIT_AUTOMAKE`运行的宏

- AC_CONFIG_FILES
- AC_OUTPUT
	这两个经常在末尾被调用，指明了哪些文件会被生成。如果以.am结尾则生成.in结尾的文件。不能识别shell变量，需要在`AC_SUBST`中注册，并且以`${xxx}`形式引用才可识别。
```make
	AC_SUBST([APIVERSION], …)
	…
	AC_CONFIG_FILES(
	  [tests/aclocal-${APIVERSION}:tests/aclocal.in],
	  [chmod +x tests/aclocal-${APIVERSION}],
	  [APIVERSION=$APIVERSION])
	AC_CONFIG_FILES(
	  [tests/automake-${APIVERSION}:tests/automake.in],
	  [chmod +x tests/automake-${APIVERSION}])
```
- 等等...

## 自动生成aclocal.m4
一些宏必须被定义在aclocal.m4中，负责autoconf不会找到他们。

aclocal可以根据configure.ac生成aclocal.m4。首先aclocal扫描所有的.m4文件搜集宏定义，然后扫描configure.ac，所有在第一步找到的宏及其依赖的宏都会被放在aclocal.m4文件中。如果本地没有找到就会在系统层面的目录中寻找。

通常宏放到aclocal.m4中是通过复制整个文件内容来完成的。但是通过命令参数`-I`来指定相对路径时，使用`m4_include`代替复制它到aclocal.m4文件中；指定绝对路径时或者是系统层面的目录时，会直接复制过来。故最好使用``-I `pwd`/reldir``代替`-I reldir`。

acinclude.m4也会被指定放到aclocal.m4文件中，建议不要在新包中使用该文件。

操作aclocal.m4时，aclocal运行`autom4te` (see [Using Autom4te](http://www.gnu.org/software/autoconf/manual/autoconf.html#Using-autom4te) in The Autoconf Manual) 追踪哪些宏被真正的使用了。autom4e也要存在于PATH环境变量中。

### aclocal接受的一些选项。
比较重要的两个选项

-I dir

    Add the directory dir to the list of directories searched for .m4 files.

--install

    Install system-wide third-party macros into the first directory specified with ‘-I dir’ instead of copying them in the output file. Note that this will happen also if dir is an absolute path.

    When this option is used, and only when this option is used, aclocal will also honor ‘#serial number’ lines that appear in macros: an M4 file is ignored if there exists another M4 file with the same basename and a greater serial number in the search path (see Serials).


### 宏搜索路径
默认的搜索路径及顺序:
- acdir-APIVERSION 		APIVERSION取决于Automake的版本
- acdir 	此目录适用于第三方.m4文件，automake构建时被配置。通常被配置为${prefix}/share/aclocal/

修改搜素路径方式一：
`-I dir1 -I dir2`
把会dir加到默认的前面：``dir1 -> dir2 -> 默认路径``

修改搜素路径方式二：
dirlist

修改搜素路径方式三：
ACLOCAL_PATH

### 编写自己的aclocal宏
这个技术可以被用于想要支持自己的Autoconf宏被其它程序使用的库（This can be used by libraries that want to supply their own Autoconf macros for use by other programs）。比如，gettext库支持AM_GNU_GETTEXT宏被用于任何使用gettext的包。库安装之后，其宏也被安装，这样aclocal就能找到它。

A macro file’s name should end in .m4. Such files should be installed in $(datadir)/aclocal. This is as simple as writing: 

	aclocaldir = $(datadir)/aclocal
	aclocal_DATA = mymacro.m4 myothermacro.m4

宏文件应该由一系列的`quoted AC_DEFUN`(see [Macro Definitions](http://www.gnu.org/software/autoconf/manual/autoconf.html#Macro-Definitions) in The Autoconf Manual)组成。

### 处理本地宏
Autoconf提供的功能测试不能满足所有的需求。人们需要用自己的宏或者第三方宏补充现有的测试。有以下两种方式：
- 在acinclude.m4中列出你所有的宏
- （推荐方法）将每个宏写到自己的文件中然后放到一个目录中（通常是m4），然后在configure.ac中添加变量：`AC_CONFIG_MACRO_DIRS([m4])`。第三方的宏文件最好也放到这个目录下。

aclocal提供了`--install`选项来复制系统层面的宏到你本地的宏目录，帮助你解决上面的问题。本地的宏比系统层面的宏有优先权。推荐在每次运行aclocal时使用`--install`选项。

### 编号
为了区分一个宏的版本。
位于M4文件的宏定义的前面。
`#`必须是此行的第一个字符，允许在version之后添加其他字符
```make
	#serial version garbage
```
使用了alcohol的--install选项的话，aclocal会选择含有#serial的或者编号比较新的那个文件。此编号对应的是整个文件，而不是单一的一个宏。

### aclocal的未来
aclocal可能会消失。因为处理M4的宏是Autoconf的任务。

永远不要自己调用aclocal，让它处于autoreconf和Automake的构建规则的控制下。

很多包含有bootstrap或者autogen.sh脚本，实际上他们只是安照正确的顺序调用命令（aclocal, libtoolize, gettextize or autopoint, autoconf, autoheader, and automake），这些工作autoreconf就可以做到。

## Automake支持的Autoconf宏
Automake附带了几个可以从configure.ac使用的Autoconf宏。

- 公共的宏 #可以使用的宏，参见[宏](宏.md)
- 废弃的宏
- 私有的宏 #被公共的宏调用，强烈建议不要调用。

# 文件夹
## 递归子文件夹
顶层的Makefile.am必须告诉Automake哪些子文件夹将被构建。通过`SUBDIRS`变量实现。

*note*：这些子文件夹中不要求含有Makefile.am文件，只要求含有Makefile文件（after configure）。

默认子文件夹会在当前目录之前构建，可以在任何位置添加`.`来改变这一顺序。
```
SUBDIRS = lib src . test
```
总是把测试的放在最后。

### SUBDIRS vs DIST_SUBDIRS

- `SUBDIRS`包含了当前目录下必须构建的子目录。需要手动定义。
- `DIST_SUBDIRS`用于需要在所有的目录下递归的规则。
- ‘make maintainer-clean’, ‘make distclean’ and ‘make dist’规则使用`DIST_SUBDIRS`，其它规则使用`SUBDIRS`。
- 如果使用Automake的conditionals定义`SUBDIRS`，Automake会自动定义`DIST_SUBDIRS`；如果`SUBDIRS`包含了`AC_SUBST`变量，`DIST_SUBDIRS`需要手动定义。

### 使用`AM_CONDITIONAL`定义子目录
举例：
```
configure
	AM_CONDITIONAL([COND_OPT], [test "$want_opt" = yes])
	AC_CONFIG_FILES([Makefile src/Makefile opt/Makefile])

Makefil.am
	if COND_OPT
	  MAYBE_OPT = opt
	endif
	SUBDIRS = src $(MAYBE_OPT)
```
在这种情况下，Automake会自动定义`DIST_SUBDIRS = src opt`，因为知道在特定的条件下*MAYBE_OPT*会含有*opt*。

### 使用`AC_SUBST`定义子目录
举例：
```
configure
	if test "$want_opt" = yes; then
	  MAYBE_OPT=opt
	else
	  MAYBE_OPT=
	fi
	AC_SUBST([MAYBE_OPT])
	AC_CONFIG_FILES([Makefile src/Makefile opt/Makefile])

Makefil.am
	SUBDIRS = src $(MAYBE_OPT)
	DIST_SUBDIRS = src opt
```
Automake不能猜测*MAYBE_OPT*的值是什么，需要手动定义`DIST_SUBDIRS`。
# 发布
## 发布基础
可以发布多种格式的发布包，不只有tar.gz。

发布包含的文件：

- 所有的源文件，Makefilea.am和Makefile.in也会进去
- Automake内置的常用文件列表，可以通过`automake --help`查看
- 一些特定条件下产生的文件（比如*AC_CONFIG_HEADERS([config.h])*产出的 *config.h.top and config.h.bot*文件）
- 被configure准备的文件
- Makefile.am中使用*include*列出的文件、configure.ac中使用*m4_include*列出的文件???
- `automake --add-missing`安装的帮助脚本

一些文件不会被规则所包含，可以在`EXTRA_DIST`中指定这些文件（夹）。指定文件夹时可能不会想要例如私有文件夹.svn被包含，可以使用特性`as-is`，也可以使用`disk-hook`特性来改善这个问题。see [The dist Hook](#dist-hook)

`SUBDIRS`也会递归的包含子目录。可以设置条件，[see Conditionals](https://www.gnu.org/software/automake/manual/automake.html#Conditionals)。如果需要有条件的指定一系列目录，可以设置`DIST_SUBDIRS`，[see Conditional Subdirectories](https://www.gnu.org/software/automake/manual/automake.html#Conditional-Subdirectories)。

## The dist Hook<span id="dist-hook"></span>
在打包之前改变。在发布文件夹被填充之后、实际发布档案被创建之前运行。
```
EXTRA_DIST = doc
dist-hook:
        rm -rf `find $(distdir)/doc -type d -name .svn`
```
该规则不会认为文件是可写的，所以需要改变文件内容时，添加想应的权限。

`(distdir)`指向当前文件夹；`$(top_distdir)`指向根目录。

*Note*：when packages are nested using AC_CONFIG_SUBDIRS (see Subpackages), then ‘$(distdir)’ and ‘$(top_distdir)’ are relative to the package where ‘make dist’ was run, not to any sub-packages involved. 

## 嵌套包
嵌套的包目录应该也在`SUBDIRS`中列出。子包的Makefile应该由自己的configure脚本生成，而不是父包的configure。通过使用`AC_CONFIG_SUBDIRS`达到这一目的。
```
arm’s configure.ac:
	
	AC_INIT([arm], [1.0])
	AC_CONFIG_AUX_DIR([.])
	AM_INIT_AUTOMAKE
	AC_PROG_CC
	AC_CONFIG_FILES([Makefile])
	# Call hand's ./configure script recursively.
	AC_CONFIG_SUBDIRS([hand])
	AC_OUTPUT

arm’s Makefile.am:
	
	# Build the library in the hand subdirectory first.
	SUBDIRS = hand

	# Include hand's header when compiling this directory.
	AM_CPPFLAGS = -I$(srcdir)/hand

	bin_PROGRAMS = arm
	arm_SOURCES = arm.c
	# link with the hand library.
	arm_LDADD = hand/libhand.a
```

# 清理
通常Automake可以自动确定清理的文件。但也提供了`MOSTLYCLEANFILES`, `CLEANFILES`, `DISTCLEANFILES`, and `MAINTAINERCLEANFILES`清理变量。

清理规则：

- 如果make构建了它并且是通常会重新构建的文件（比如.o文件），那么`mostclean`删除它。
- 如果make构建了它，那么`clean`删掉它。
- 如果是configure构建了它，那么`distclean`删除。
- 如果是维护这构建的，那么`maintainer-clean`删除。不能清理运行`./configure && make`所必须的文件。

可以扩展。

# 测试套件的支持
测试套件由一系列的测试用例组成。

跳过测试：测试没有意义，测试条件不满足。

硬错误：测试场景不对，一些意外情况。

基于通用测试脚本，通过定义特殊变量`TEST`激活。

预期失败*expected failure (xfail)*，未预计的通过*unexpected pass (xpass)*。

## 简单测试

### 基于脚本的测试套件
如果`TEST`变量被定义了，其值是执行测试的程序或脚本列表。

测试脚本可以并行或串行执行，默认的并行测试套件是*parallel test harness*。
默认的测试结果是测试脚本的退出结果。

Automake也支持更多的协议：standard (see [Using the TAP test protocol](https://www.gnu.org/software/automake/manual/automake.html#Using-the-TAP-test-protocol)) 和 custom (see [Custom Test Drivers](https://www.gnu.org/software/automake/manual/automake.html#Custom-Test-Drivers))。

*note*：不能在串行中使用这些协议。

不使用测试协议的时候，测试脚本的退出码的意义如下：

- 0	- 成功
- 77 - 跳过该测试
- 99 - 硬错误
- 其它 - 失败

可以使用`XFAIL_TESTS`变量列出*xfail*的测试。定义`DISABLE_HARD_ERRORS`变量为非空值来项普通的错误一样对待硬错误。

*note*：使用测试协议的时候，这两个变量不会起作用。
```
PASS: foo.sh
PASS: zardoz.tap 1 - Daemon started
PASS: zardoz.tap 2 - Daemon responding
SKIP: zardoz.tap 3 - Daemon uses /proc # SKIP /proc is not mounted
PASS: zardoz.tap 4 - Daemon stopped
SKIP: bar.sh
PASS: mu.tap 1
XFAIL: mu.tap 2 # TODO frobnication not yet implemented
```
`AM_COLOR_TESTS=always`，彩色输出。

`AM_TESTS_ENVIRONMENT and TESTS_ENVIRONMENT`变量用于给测试脚本运行初始化代码和设置环境变量。前者是开发人员保留的，后者是用户保留的（可扩展并且覆盖前者的设置）。非空的`AM_TESTS_ENVIRONMENT`必须以分号结束，且不支持串行测试。

Automake会保证每个在`TEST`中列出的文件在运行之前被构建。

### 串行测试
**强烈不推荐使用。**

通过Automake选项*serial-tests*实现串行测试

### 并行测试
*make -j*执行并行测试。
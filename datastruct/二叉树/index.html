<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="shihr">
    
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>二叉树 - Sink</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u5b58\u50a8\u7ed3\u6784", url: "#_top", children: [
          ]},
          {title: "\u5de5\u5177\u51fd\u6570", url: "#_2", children: [
          ]},
          {title: "get\u65b9\u6cd5", url: "#get", children: [
          ]},
          {title: "\u63d2\u5165\u65b9\u6cd5", url: "#_3", children: [
          ]},
          {title: "\u5220\u9664\u65b9\u6cd5", url: "#_4", children: [
          ]},
          {title: "\u83b7\u53d6\u6781\u503c", url: "#_5", children: [
          ]},
          {title: "\u5411\u4e0a\u3001\u5411\u4e0b\u53d6\u6574", url: "#_6", children: [
          ]},
          {title: "\u6309\u5e8f\u83b7\u53d6\uff0c\u6b21\u5e8f", url: "#_7", children: [
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../散列表/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../散列表/" class="btn btn-xs btn-link">
        散列表
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../gerrit/刷新gerrit项目列表/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../gerrit/刷新gerrit项目列表/" class="btn btn-xs btn-link">
        刷新gerrit项目列表
      </a>
    </div>
    
  </div>

    

    <p>使用二叉树实现有序符号表。</p>
<h4 id="_1">存储结构</h4>
<pre><code class="java">/**
 * 二叉查找树有序符号表，插入和查找都很快
 */
public class BST&lt;K extends Comparable&lt;K&gt;, V&gt;{
    private Node root;  // 根节点
    private int base;

    void setRoot(Node node){
        this.root = node;
    }

    private class Node {
        private K k;
        private V v;
        private Node left, right;
        private int N;  // 该子树的节点数

        private Node(K k, V v, int N) {
            this.k = k;
            this.v = v;
            this.N = N;
        }
    }
</code></pre>

<h4 id="_2">工具函数</h4>
<pre><code class="java">    public int size(){
        return size(root);
    }

    private int size(Node x){
        if (null == x){
            return 0;
        }
        return x.N;
    }

    boolean isEmpty(){
        return root == null;
    }


</code></pre>

<h4 id="get">get方法</h4>
<pre><code class="java">    //迭代实现
    V get(K k) {
        /*Node tmp = root;

        while (tmp != null){
            int re = k.compareTo(tmp.k);
            if (re == 0){
                return tmp.v;
            }else if (re &gt; 0){
                tmp = tmp.right;
            }else {
                tmp = tmp.left;
            }
        }

        return null;*/

        //递归实现
        return get(root, k);
    }
    //递归实现
    private V get(Node x, K k){
        if (null == x){
            return null;
        }

        int re = k.compareTo(x.k);
        if (re == 0){
            return x.v;
        }else if (re &gt; 0){
            return get(x.right, k);
        }else {
            return get(x.left, k);
        }
    }
</code></pre>

<h4 id="_3">插入方法</h4>
<pre><code class="java">    //迭代实现
    void put(K k, V v) {
/*        if (null == root){
            root = new Node(k, v, 1);
            return;
        }

        Node tmp = root;

        while (true){
            int re = k.compareTo(tmp.k);
            if (re == 0){  // 等于当前节点
                tmp.v = v;
                break;
            }else if(re &gt; 0){  // 大于
                tmp.N++;
                if (tmp.right == null){
                    tmp.right = new Node(k, v, 1);
                    break;
                }else {
                    tmp = tmp.right;
                }
            }else {  // 小于
                tmp.N++;
                if (tmp.left == null){
                    tmp.left = new Node(k, v, 1);
                    break;
                }else {
                    tmp = tmp.left;
                }
            }
        }*/
        //递归实现
        root = put(root, k, v);
    }

    //递归实现
        Node put(Node h, K k, V v){
        if (h == null){
            return new Node(k, v, 1);
        }

        int re = k.compareTo(h.k);
        if (re &lt; 0){
            h.left = put2(h.left, k, v);
        }else if (re &gt; 0){
            h.right =  put2(h.right, k, v);
        }else {
            h.v = v;
            return h;
        }

        //别忘了调整大小！！！
        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
</code></pre>

<h4 id="_4">删除方法</h4>
<pre><code class="java">    void delete(K k) {
        root = delete(root, k);
    }

    private Node delete(Node x, K k){
        if (x == null) {
            return null;
        }

        int re = k.compareTo(x.k);
        if (re &gt; 0 ){  //forward and rebuild right-tree
            x.right =  delete(x.right, k);
        }else if (re &lt; 0){  //forward and rebuild left-tree
            x.left = delete(x.left, k);
        }else {  //x = deleteNode
            if (x.left == null){  //only right-tree exist or null
                return x.right;
            }else if (x.right == null){  //only left-tree exist or null
                return x.left;
            }else {  //both left and right tree
                Node t = x;
                x = min(t.right);
                x.right = deleteMin(t.right);
                x.left = t.left;
            }
        }

        x.N = size(x.left) + size(x.right) + 1;
        return x;
    }

    void deleteMin() {
        if(isEmpty()){  //防止空指针异常
            return;
        }

        root = deleteMin(root);
    }

    private Node deleteMin(Node x){
        if (x.left == null){  //返回到上一级结点
            return x.right;  //注意此处返回的是右子结点
        }

        x.left = deleteMin(x.left);  //更新左结点
        x.N = size(x.left) + size(x.right) + 1;
        return x;
    }

    void deleteMax() {
        if (isEmpty()){
            return;
        }

        root = deleteMax(root);
    }

    private Node deleteMax(Node x){
        if (x.right == null){
            return x.left;
        }

        x.right = deleteMax(x.right);
        x.N = size(x.left) + size(x.right) + 1;
        return x;
    }
</code></pre>

<h4 id="_5">获取极值</h4>
<pre><code class="java">    K min() {
        if (isEmpty()){
            return null;
        }

        //递归实现
        return min(root).k;
    }

    private Node min(Node x){
        if (x.left == null){
            return x;
        }else {
            return min(x.left);
        }
    }

    //迭代实现
    K max() {
        if (isEmpty()){
            return null;
        }else {
            Node tmp = root;
            while (tmp != null){
                if (tmp.right == null){
                    return tmp.k;
                }else {
                    tmp = tmp.right;
                }
            }
        }

        return null;
    }
</code></pre>

<h4 id="_6">向上、向下取整</h4>
<pre><code class="java">    K floor(K k) {
        /*
        向下取整；小于等于k的最大值
        */
        if (isEmpty()){
            return null;
        }

        //recursive
        return floor(root, k).k;
    }

    private Node floor(Node x, K k){
        if (x == null){  //到达叶子节点的空枝
            return null;
        }

        int re = k.compareTo(x.k);
        if (re == 0){
            return x;
        }else if(re &lt; 0){  //left-tree
            return floor(x.left, k);
        }

        Node tmp = floor(x.right, k);  //right-tree
        if (tmp == null){
            return x;
        }else {
            return tmp;
        }
    }

    K ceiling(K k) {
        if(isEmpty()){
            return null;
        }

        return ceiling(root, k).k;
    }

    private Node ceiling(Node x, K k){
        /*
        向上取整；大于等于k的最小值
        */
        if (x == null){
            return null;
        }

        int re = k.compareTo(x.k);
        if (re == 0){
            return x;
        }else if(re &gt; 0){
            return ceiling(x.right, k);
        }

        Node tmp = ceiling(x.left, k);
        if (tmp == null){
            return x;
        }else {
            return tmp;
        }

    }
</code></pre>

<h4 id="_7">按序获取，次序</h4>
<pre><code class="java">    K select(int i) {
        /*
        获取第i个值
        */
        Node re =  select(root, i);
        if (re == null){
            return null;
        }else {
            return re.k;
        }
    }

    private Node select(Node x, int i){
        if (x == null){
            return null;
        }

        int tmp = size(x.left);
        if (tmp == i){
            return x;
        }else if(tmp &gt; i){
            return select(x.left, i);
        }else {
            return select(x.right, i-tmp-1);
        }
    }

    int rank(K k) {
        /*
        次序
        */
        return rank(root, k);
    }

    private int rank(Node x, K k){
        if (x == null){
            return 0;
        }

        int tmp = size(x.left);
        int re = k.compareTo(x.k);
        if (re == 0){
            return tmp;
        }else if(re &gt; 0){
            return tmp + rank(x.right, k) + 1;
        }else {
            return rank(x.left, k);
        }
    }

    void print(){
        print(root);
    }

    private void print(Node x){
        if (x == null){
            return;
        }
        print(x.left);
        System.out.println(x.k);
        print(x.right);
    }
}
</code></pre>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../散列表/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../散列表/" class="btn btn-xs btn-link">
        散列表
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../gerrit/刷新gerrit项目列表/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../gerrit/刷新gerrit项目列表/" class="btn btn-xs btn-link">
        刷新gerrit项目列表
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>